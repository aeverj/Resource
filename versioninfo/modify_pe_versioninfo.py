# 需要先安装 pe_tools: pip install pe_tools

import random
import string
import os
import argparse # 导入 argparse 模块用于处理命令行参数

COMPANY_NAMES = [
    "Microsoft Corporation", "Google LLC", "Apple Inc.", "Amazon.com, Inc.", "Facebook, Inc.",
    "Oracle Corporation", "IBM Corporation", "Intel Corporation", "Adobe Inc.", "Salesforce.com, Inc.",
    "NVIDIA Corporation", "Cisco Systems, Inc.", "VMware, Inc.", "Netflix, Inc.", "PayPal Holdings, Inc.",
    "Zoom Video Communications, Inc.", "Twitter, Inc.", "Uber Technologies, Inc.", "Lyft, Inc.",
    "Airbnb, Inc.", "Spotify Technology S.A.", "Slack Technologies, Inc.", "Dropbox, Inc.",
    "Electronic Arts Inc.", "Activision Blizzard, Inc."
]

PRODUCT_NAMES = [
    "Windows", "Google Chrome", "iOS", "Amazon Prime", "Facebook Messenger",
    "Oracle Database", "IBM Watson", "Intel Core", "Adobe Photoshop", "Salesforce CRM",
    "NVIDIA GeForce", "Cisco Webex", "VMware vSphere", "Netflix Streaming", "PayPal",
    "Zoom Meetings", "Twitter Feed", "Uber Ride", "Lyft Ride", "Airbnb Stay",
    "Spotify Music", "Slack Collaboration", "Dropbox Storage", "EA Sports FIFA", "Call of Duty"
]

def generate_version_info():
    """生成随机的版本信息字典"""
    # 随机选择公司名称和产品名称
    company_name = random.choice(COMPANY_NAMES)
    product_name = random.choice(PRODUCT_NAMES)

    # 生成文件版本和产品版本 (4位和3位)
    file_version = '.'.join(str(random.randint(0, 9)) for _ in range(4))
    product_version = '.'.join(str(random.randint(0, 9)) for _ in range(3))

    # 构造版本信息字典
    version_info = {
        "CompanyName": company_name,
        "FileDescription": f"{product_name} Application",
        "FileVersion": file_version,
        "InternalName": product_name.replace(" ", ""), # 内部名称通常不含空格
        "LegalCopyright": f"© {random.randint(1995, 2024)} {company_name}. All rights reserved.", # 更新年份范围
        "OriginalFilename": f"{product_name.replace(' ', '')}.exe", # 原始文件名通常不含空格
        "ProductName": product_name,
        "ProductVersion": product_version,
        "Comments": f"Generated by Version Info Tool. Copyright (c) {random.randint(1995, 2024)}", # 添加更具体的注释
    }
    return version_info

if __name__ == "__main__":
    # --- 处理命令行参数 ---
    parser = argparse.ArgumentParser(description="Modify PE file version information using random data.")
    # 添加一个必需的位置参数 'filepath'，用于指定目标 .exe 文件
    parser.add_argument("filepath", help="Path to the target executable file (.exe)")
    # 解析命令行传入的参数
    args = parser.parse_args()

    # 检查文件是否存在
    if not os.path.isfile(args.filepath):
        print(f"Error: File not found at '{args.filepath}'")
        exit(1) # 文件不存在则退出

    # --- 生成并应用版本信息 ---
    version_info = generate_version_info()
    print("Generated Version Info:")
    for k, v in version_info.items():
        print(f"  {k}: {v}")

    # 构建 peresed 命令的参数字符串
    peresed_args = ''
    for k, v in version_info.items():
        # 确保值中的引号被正确处理 (虽然在这个例子中不太可能出现，但这是个好习惯)
        escaped_v = v.replace('"', '\\"')
        one_arg = f'-V "{k}={escaped_v}" '
        peresed_args += one_arg

    # 构建完整的命令行指令，使用从命令行获取的文件路径
    # 注意：确保 peresed 命令在你的系统 PATH 中，或者提供其完整路径
    cmd_args = f"peresed {peresed_args} \"{args.filepath}\"" # 将文件路径用引号括起来，以处理可能包含空格的路径

    print('='*50)
    print(f"Executing command: {cmd_args}")
    print('='*50)

    # 执行命令
    return_code = os.system(cmd_args)

    # 检查命令执行结果
    if return_code == 0:
        print(f"\nSuccessfully modified version info for '{args.filepath}'")
    else:
        print(f"\nError executing peresed command. Return code: {return_code}")
